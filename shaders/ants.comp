#version 430

/*
in uvec3 gl_NumWorkGroups;
in uvec3 gl_WorkGroupID;
in uvec3 gl_LocalInvocationID;
in uvec3 gl_GlobalInvocationID;
in uint gl_LocalInvocationIndex;
*/

#define SPEED 1.0
#define PI 3.1415926535897932384626

struct Ant {
  float position_x;
  float position_y;

  float direction_x;
  float direction_y;

  uint food_quantity;
  uint is_alive;

  uint anthill_position_x;
  uint anthill_position_y;
};

layout(local_size_x = 50, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = 0) buffer ant_layout { Ant ant_data[]; };
layout(binding = 1, r8ui) uniform uimage2D af_tex;
layout(binding = 2, r16f) uniform image2D pher_tex;
layout(binding = 3, rgba32f) uniform image2D render_tex;
layout(location = 1) uniform float delta_time;

float rand(vec2 co) {
  return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
}

void main() {
  uint ant_index = gl_GlobalInvocationID.x;

  if (ant_data[ant_index].is_alive == 0) {
    return;
  }

  // If the ant is out of the render texture, it turns around
  if (ant_data[ant_index].position_x < 0.0 || ant_data[ant_index].position_x > 1024.0 || ant_data[ant_index].position_y < 0.0 || ant_data[ant_index].position_y > 1024.0) {
	  ant_data[ant_index].direction_x *= -1.0;
	  ant_data[ant_index].direction_y *= -1.0;
  }

  // Normalize direction
  float length = sqrt(ant_data[ant_index].direction_x * ant_data[ant_index].direction_x + ant_data[ant_index].direction_y * ant_data[ant_index].direction_y); 
  ant_data[ant_index].direction_x /= length;

  if (ant_data[ant_index].food_quantity <= 0) {
    uint af_value = uint(imageLoad(af_tex, ivec2(ant_data[ant_index].position_x, ant_data[ant_index].position_y)).r);
    uint food_below = uint(af_value & 0x7F);
    uint anthill_value = uint(af_value & 0x80);

    if (food_below >= 0) {
      // Update the food values
      /*
      int updated_food_below = int(food_below) - int(5 - ant_data[ant_index].food_quantity);
      ant_data[ant_index].food_quantity += int(food_below) - updated_food_below;
      imageStore(af_tex, ivec2(ant_data[ant_index].position_x, ant_data[ant_index].position_y), uvec4(max(updated_food_below, 0) | anthill_value));

      // Return to the anthill
      
      ant_data[ant_index].direction_x = ant_data[ant_index].anthill_position_x - ant_data[ant_index].position_x;
      ant_data[ant_index].direction_y = ant_data[ant_index].anthill_position_y - ant_data[ant_index].position_y;
      */
    } else {
      // If the ant perceives pheromones at any angle between -pi/2 and pi/2 and a distance of 8 or less
      // in fronts of it, it moves to the highest pheromone value
      float max_pheromones = 0.0;
      float max_pheromones_x = 0.0;
      float max_pheromones_y = 0.0;

      for (float angle = -PI/2; angle < PI/2; angle += PI/16) {

        for (int distance = 0; distance <= 8; distance++) {
          float current_angle = atan(ant_data[ant_index].direction_y / ant_data[ant_index].direction_x);
          float x = ant_data[ant_index].position_x + distance * cos(angle + current_angle);
          float y = ant_data[ant_index].position_y + distance * sin(angle + current_angle);

          float pheromones = imageLoad(pher_tex, ivec2(x, y)).r;

          if (pheromones > max_pheromones) {
            max_pheromones = pheromones;
            max_pheromones_x = x;
            max_pheromones_y = y;
          }
        }
      }

      if (max_pheromones > 0.0) {
        ant_data[ant_index].direction_x = max_pheromones_x - ant_data[ant_index].position_x;
        ant_data[ant_index].direction_y = max_pheromones_y - ant_data[ant_index].position_y;
      } else {
        // If the ant doesn't perceive pheromones, it rotates randomly 
        // between -pi/10 * delta_time and pi/10 * delta_time
        float angle = (int(rand(vec2(29.0, -52.0))) % 20 - 10) * PI / 180.0 * delta_time;
        float new_direction_x = ant_data[ant_index].direction_x * cos(angle) - ant_data[ant_index].direction_y * sin(angle);
        float new_direction_y = ant_data[ant_index].direction_x * sin(angle) + ant_data[ant_index].direction_y * cos(angle);

        ant_data[ant_index].direction_x = new_direction_x;
        ant_data[ant_index].direction_y = new_direction_y;
      }
    }
  }

  length = sqrt(ant_data[ant_index].direction_x * ant_data[ant_index].direction_x + ant_data[ant_index].direction_y * ant_data[ant_index].direction_y);
  ant_data[ant_index].direction_x /= length;

  // move the ant in the direction it is facing
  // and add pheromones : 100 if the ant has food, 10 otherwise
  float currentPheromones = imageLoad(pher_tex, ivec2(ant_data[ant_index].position_x, ant_data[ant_index].position_y)).r;
  imageStore(pher_tex, ivec2(ant_data[ant_index].position_x, ant_data[ant_index].position_y), vec4((ant_data[ant_index].food_quantity > 0 ? 100.0 : 10.0)*delta_time*10 + currentPheromones));

  ant_data[ant_index].position_x +=
      ant_data[ant_index].direction_x * delta_time;
  ant_data[ant_index].position_y +=
      ant_data[ant_index].direction_y * delta_time;
}
